Amazon Locker

Requirements :-

Assign a closest locker to a person given current co-ordinates( where customer wants )
After order is delivered by courier service to customer specified amazon locker, a 6 digit code will be sent to customer .
Item will be placed in Amazon locker for 3 days
After 3 days, if Item is not picked up from the locker, refund process will be initiated
Amazon locker will be assigned to customer based on the size of the locker ( S,M,L,XL,XXL)
Only items that are eligible to be put in locker can be assigned to amazon locker .i.e Not all items can be placed inside locker (like furniture can't be put inside amazon locker)
Access to Amazon locker will depend on Store's opening and closing time.(Since Amazon locker are placed inside stores,malls etc)
Items can be returned to Amazon locker as well .
Items that are eligible Amazon locker item, can only be returned by customer
Once the Door is closed. User's code will be expired. (User will not be able to open the locker now)
Questions I will ask from interviewer :

Who are my customers ? probable answer would be courier guys (For delivery : FedX,Bluedart and For accepting order : Customer who buys)
How many are they?
Is this service to avail globally or to certain cities within a country ?
How many user request may come in a single minute ?
Scenario :

Customer added (amazon locker eligible) item in a cart from amazon.com
there will be cart Microservice that will forward the request to Amazon locker location tracking service based on current location of the user, item size requested
Internal server api call will contains following parameters
List find_Locker(item_id,size_requested,customer_latitude,customer_longitude)

This will find all the lockers based on the size_requested by the customer
All the lockers can be put in a data structure like (K_dimension tree), to effectively search lockers, based on k dimensions
where dimesnsions could be location,size,availibility

Each locker Obect have the property
Locker {
Locker_id
size,
locker_status
}

locker_status {
Booked
Free

}

on next screen user will get the list of nearest amazon lockers available with their address details and their closing and opening timings.

User selects one of the amazon locker from the given lockers location list

api request like (item_id, locker_id,payment_status,expected_delivery_date) will be made from the client side.
6a. Now the locker_id status will be changed to BOOKED, only when payment Status = OK
6a i. when the locker is booked, an RDMS transaction will be commited and locker_status will be changed to BOOKED
Note : we will use RDMS database (MySQL) because locker booking status needs consistency. so MYSQL transactions will provide ACID properties with BEGIN Transaction
and COMMIT feature for booking a current locker. SO that in distributed environment , other customers can not book the same locker.
6a ii. when payment_status is NOT_OK, locker_id will not be booked . error message will be spawned from the (amazon locker booking service) microservice directly to theclient

when the locker is booked. locker_staus will be : BOOKED of given locker_ID

Given locker_id will not be sent to AMAZON LOCKER.

AMAZON LOCKER -> is the actual locker at a particular store
AMAZON LOCKER will generate a two 6 digit code for a given locker_ID

one for BlueDart delivery service and will send code to
one for Customer , code will be generated after Bluedart delivery service has placed the order and closed the door.
Amazon Locker will send this code to Amazon App server.

Code generated by Amazon Locker will be sent through messaging queue.

Messaging queue(like Rabbit MQ) will send the code to app server and client(subscriber)

App server will store the code in their db as well

After customer has taken out the order from the order . Locker status will be changed to FREE and same status will be deliverd by AMAZON locker system to app server, which will in turn will update the locker_id to db.

IF AMAZON LOCKER is closed from 3 days. a request to app server is made to delivery service to pickup the item from the given locker id.

```java
package LockerSystem;

public class Locker {
    public String sizeString;
    public int sizeInt;
    public int[] pin;
    public boolean isOcuppied;
    public int id;
    public Package pack;
    public Locker(int size, String lockerSizeString, int id){
        sizeInt = size;
        this.id = id;
        this.sizeString = lockerSizeString;
    }
    public void allocatePackage(Package pack, int[] pin){
        this.pack = pack;
        isOcuppied = true;
        this.pin = pin;
    }
    public void deallocatePackage(){
        this.pack = null;
        isOcuppied = false;
        this.pin = null;
    }
}

package LockerSystem;

public class Package {
    public String sizeString;
    public int sizeInt;
    public boolean isInsideLocker;
    public String id;
    public int savedLockerId;
    public int idSize = 5;
    public Package(int sizeInt, String sizeString, int lockerId){
        this.sizeInt = sizeInt;
        this.sizeString = sizeString;
        savedLockerId = lockerId;
        generateId();
    }
    public void generateId(){
        id = "";
        for(int i = 0; i < idSize; i++){
            id += (char) ((int)Math.random()*26.0)+65;
        }
    }

}



package LockerSystem;

import LockerSystem.Location;
import LockerSystem.Locker;

import java.util.HashMap;
import java.util.LinkedList;
public class PickUpLocation {
    public boolean isFull;
    public String[] sizes = {"small","medium","large"};
    public int[] availableLockersPerSize;
    public int totalLockers;
    public Location location;

    HashMap<Integer, Locker> lockers;
    HashMap<Integer,LinkedList<Locker>> availableLockers;

    HashMap<String, Package> packages;

    public PickUpLocation(int[] availableLockersPerSize){
        this.availableLockersPerSize = availableLockersPerSize;
        totalLockers = 0;
        for(int i = 0; i < availableLockersPerSize.length; i++){
            LinkedList<Locker> auxList = new LinkedList<>();
            for(int e = 0; e < availableLockersPerSize[i]; e++){
                Locker currentLocker = new Locker(i,sizes[i],totalLockers);
                lockers.put(totalLockers,currentLocker);
                auxList.push(currentLocker);
                totalLockers++;
            }
            availableLockers.put(i,auxList);
        }
    }
    public void determineIsFull(){
        isFull = (totalLockers == packages.size());
    }
    public Locker getAvailableLocker(Package toAllocate){
        for(int i = toAllocate.sizeInt; i < sizes.length; i++) {
            if(availableLockers.get(i).size() > 0){
                Locker availableLocker = availableLockers.get(i).poll();
                return availableLocker;
            }
        }
        return null;
    }
    public boolean allocatePackage(Package toAllocate, int[] pin){
        determineIsFull();
        if(!isFull){
            packages.put(toAllocate.id,toAllocate);
            Locker toUse = getAvailableLocker(toAllocate);
            if(toUse != null){
                toUse.allocatePackage(toAllocate, pin);
                 availableLockers.get(toUse.sizeInt).remove(toUse);
                return true;
            }
            else{
                return false;
            }
        }
        else{
            return false;
        }
    }
    public boolean deallocatePackage(String toDeallocateId, int[] pin){
        if(packages.containsKey(toDeallocateId)){
            Package toDeallocatePackage = packages.get(toDeallocateId);
            packages.remove(toDeallocateId);
            Locker toDeallocateLocker = lockers.get(toDeallocatePackage.savedLockerId);
            toDeallocateLocker.deallocatePackage();
            availableLockers.get(toDeallocateLocker.sizeInt).add(toDeallocateLocker);
            return true;
        }
        else
            return false;
    }
}
```

```python
__author__ = 'deepika'


class Locker:

    def __init__(self, id, capacity, Level):
        self.id = id
        self.capacity = capacity
        self.level = Level
        self.occupied = False
        [#Other](https://leetcode.com/problems/subtree-of-another-tree) meta Data goes here. For instance passcode, LastAccessedTime.
        # Functions Like: resetPassCode(), makeAvailable(), generatePassCode() etc

    def __repr__(self):
        return "[" + str(self.id) + ", " + str(self.capacity) + ", " + str(self.level) + "]"

    def markoccupied(self):
        self.occupied = True

class System:

    def __init__(self):
        self.lockers = []

    def addLocker(self, l):
        self.lockers.append(l)

    def findBestLocker(self, requiredCapacity):

        if len(self.lockers) == 0:
            return "No Lockers available"

        unOccupiedLockers = filter(lambda x: x.occupied == False, self.lockers)

        unOccupiedLockers = sorted(unOccupiedLockers, key=lambda x: (x.capacity, x.level))

        if len(unOccupiedLockers) == 0 or requiredCapacity > unOccupiedLockers[len(unOccupiedLockers) - 1].capacity:
            return None

        left = 0
        right = len(unOccupiedLockers) - 1

        while left <= right:
            mid = (right + left)/2

            if unOccupiedLockers[mid].capacity == requiredCapacity:
                unOccupiedLockers[mid].markoccupied()
                return "Locker Provided: ", unOccupiedLockers[mid]

            if unOccupiedLockers[mid].capacity <= requiredCapacity <= unOccupiedLockers[mid+1].capacity:
                if unOccupiedLockers[mid].capacity - requiredCapacity >= 0: # Image Locker as 2, 4, 5 and you are looking for 3. Even if you ocrrectly identify range (2, 4) that won't be enough
                    unOccupiedLockers[mid].markoccupied()
                    return "Locker Provided: ", unOccupiedLockers[mid]
                else:
                    unOccupiedLockers[mid+1].markoccupied()
                    return "Locker Provided: ", unOccupiedLockers[mid + 1]

            elif unOccupiedLockers[mid].capacity > requiredCapacity:
                right = mid - 1
            else:
                left = mid + 1

        return "No Lockers available"


l1 = Locker(1, 1, 1)
l2 = Locker(2, 7, 2)
l3 = Locker(3, 10, 2)
l4 = Locker(4, 5, 2)
l5 = Locker(5, 2, 1)
l6 = Locker(6, 15, 3)
l7 = Locker(7, 1, 1)

s=System()
s.addLocker(l1)
s.addLocker(l2)
s.addLocker(l3)
s.addLocker(l4)
s.addLocker(l5)
s.addLocker(l6)
s.addLocker(l7)

print(s.findBestLocker(3))
print(s.findBestLocker(12))
print(s.findBestLocker(9))
print(s.findBestLocker(7))
```
